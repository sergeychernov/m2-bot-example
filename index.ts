import { Bot, InlineKeyboard } from 'grammy'; // webhookCallback ÑƒÐ´Ð°Ð»ÐµÐ½, Ñ‚Ð°Ðº ÐºÐ°Ðº Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ð½Ð°Ð¿Ñ€ÑÐ¼ÑƒÑŽ Ð² handler
import fs from 'fs';
import path from 'path';

const botToken = process.env.BOT_TOKEN;
if (!botToken) {
  throw new Error('BOT_TOKEN must be provided!');
}
const bot = new Bot(botToken);

// Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ð°Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð´Ð»Ñ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ñ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸
let botInitialized = false;

// ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð¾Ñ‚Ð°
async function initializeBot() {
  if (botInitialized) return;
  try {
    console.log('Initializing bot...');
    await bot.init(); // Ð¯Ð²Ð½Ð¾ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð¾Ñ‚Ð°, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ botInfo (ctx.me)
    console.log(`Bot initialized: ${bot.botInfo.username} (ID: ${bot.botInfo.id})`);

    // Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ñ… ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð² Ð¼ÐµÐ½ÑŽ Ð±Ð¾Ñ‚Ð°
    // Ð­Ñ‚Ð¾ Ð½ÑƒÐ¶Ð½Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð¿Ð¾ÑÐ»Ðµ bot.init(), Ñ‚Ð°Ðº ÐºÐ°Ðº bot.api Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð½Ðµ Ð³Ð¾Ñ‚Ð¾Ð²
    await bot.api.setMyCommands([
      { command: 'start', description: 'ÐÐ°Ñ‡Ð°Ñ‚ÑŒ Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ Ñ Ð±Ð¾Ñ‚Ð¾Ð¼' },
      { command: 'help', description: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÐ¿Ñ€Ð°Ð²ÐºÑƒ' },
      { command: 'clients', description: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²' }
    ]);
    console.log('Bot commands set.');
    botInitialized = true;
  } catch (error) {
    console.error('Failed to initialize bot or set commands:', error);
    // Ð’ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ñ‚ ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡Ð½Ð¾ÑÑ‚Ð¸, Ð¼Ð¾Ð¶Ð½Ð¾ Ð»Ð¸Ð±Ð¾ Ð²Ñ‹Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð¾ÑˆÐ¸Ð±ÐºÑƒ Ð´Ð°Ð»ÑŒÑˆÐµ, Ð»Ð¸Ð±Ð¾ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÑŒ Ð±ÐµÐ· ÐºÐ¾Ð¼Ð°Ð½Ð´
    // throw error; // Ð Ð°ÑÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ, ÐµÑÐ»Ð¸ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡Ð½Ð°
  }
}

// Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑŽ Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð· (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, Ð¿Ñ€Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¼ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ñ)
// Ð’ ÑÐµÑ€Ð²ÐµÑ€Ð½Ð¾Ð¹ ÑÑ€ÐµÐ´Ðµ ÑÑ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒÑÑ Ð¿Ñ€Ð¸ "Ñ…Ð¾Ð»Ð¾Ð´Ð½Ð¾Ð¼ ÑÑ‚Ð°Ñ€Ñ‚Ðµ"
// initializeBot(); // Ð’Ñ‹Ð·Ð¾Ð² Ð·Ð´ÐµÑÑŒ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°Ñ‚Ð¸Ñ‡ÐµÐ½, ÐµÑÐ»Ð¸ top-level await Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð¸Ð»Ð¸ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹
// Ð›ÑƒÑ‡ÑˆÐµ Ð²Ñ‹Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ ÐµÐ³Ð¾ Ð² Ð½Ð°Ñ‡Ð°Ð»Ðµ handler, ÐµÑÐ»Ð¸ ÑÑ‚Ð¾ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð²Ñ‹Ð·Ð¾Ð².

interface Client { 
  id: string;
  firstName: string;
  lastName: string;
  category: 'buyer' | 'seller';
  status: 'active' | 'archived' | 'banned';
  username?: string;
  propertyInfo: {
    type: string;
    requirements?: string;
    description?: string;
    price?: number;
  };
}

// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð² Ð¸Ð· JSON Ñ„Ð°Ð¹Ð»Ð°
const loadClients = (): Client[] => {
  try {
    const filePath = path.resolve(__dirname, 'clients.json');
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(fileContent) as Client[];
  } catch (error) {
    console.error('Error loading clients.json:', error);
    return [];
  }
};

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /start
bot.command('start', async (ctx) => {
  // ctx.me Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±Ñ‹Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½, ÐµÑÐ»Ð¸ initializeBot() Ð±Ñ‹Ð» Ð²Ñ‹Ð·Ð²Ð°Ð½
  const firstName = ctx.from?.first_name || 'Ñ€Ð¸ÐµÐ»Ñ‚Ð¾Ñ€';
  const botUsername = ctx.me?.username || 'your_bot_username'; // Ð”Ð¾Ð±Ð°Ð²Ð¸Ð¼ Ð·Ð°Ð¿Ð°ÑÐ½Ð¾Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚
  const botLink = `https://t.me/${botUsername}`;
  const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(botLink)}`;

  await ctx.replyWithPhoto(qrCodeUrl, {
    caption: `ÐŸÑ€Ð¸Ð²ÐµÑ‚, ${firstName}! ðŸ‘‹\n\nÐ¯ Ð²Ð°Ñˆ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð½Ð¸Ðº Ð² Ñ€Ð°Ð±Ð¾Ñ‚Ðµ Ñ Ð½ÐµÐ´Ð²Ð¸Ð¶Ð¸Ð¼Ð¾ÑÑ‚ÑŒÑŽ. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ ÑÑ‚Ð¾Ñ‚ QR-ÐºÐ¾Ð´, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð¼Ð¾Ð¸Ð¼ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¾Ð¼ Ñ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°Ð¼Ð¸.`
  });
});

// ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /help
bot.command('help', async (ctx) => {
  await ctx.reply(
    'Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹:\n' +
    '/start - ÐÐ°Ñ‡Ð°Ñ‚ÑŒ Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ Ñ Ð±Ð¾Ñ‚Ð¾Ð¼\n' +
    '/help - ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÑ‚Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ\n' +
    '/clients - ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²'
  );
});

// ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /clients
bot.command('clients', async (ctx) => {
  const keyboard = new InlineKeyboard()
    .text('ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñ‹', 'active_clients').row()
    .text('ÐÑ€Ñ…Ð¸Ð²Ð½Ñ‹Ðµ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñ‹', 'archived_clients').row()
    .text('Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñ‹', 'blocked_clients');
  await ctx.reply('Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑŽ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²:', { reply_markup: keyboard });
});

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ Ð´Ð»Ñ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹ Ñ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°Ð¼Ð¸ (callback_query)
bot.callbackQuery('active_clients', async (ctx) => {
  await ctx.answerCallbackQuery();
  const clients = loadClients();
  const activeClients = clients.filter(client => client.status === 'active');

  if (activeClients.length === 0) {
    await ctx.reply('ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð² Ð½ÐµÑ‚.');
    return;
  }

  const keyboard = new InlineKeyboard();
  activeClients.forEach(client => {
    keyboard.text(`${client.firstName} ${client.lastName}`, `client_${client.id}`).row();
  });

  await ctx.reply('Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²:', { reply_markup: keyboard });
});

bot.callbackQuery('archived_clients', async (ctx) => {
  await ctx.answerCallbackQuery();
  await ctx.reply('Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð°Ñ€Ñ…Ð¸Ð²Ð½Ñ‹Ñ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²:');
  // TODO: Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð»Ð¾Ð³Ð¸ÐºÑƒ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ° Ð°Ñ€Ñ…Ð¸Ð²Ð½Ñ‹Ñ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²
});

bot.callbackQuery('blocked_clients', async (ctx) => {
  await ctx.answerCallbackQuery();
  await ctx.reply('Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²:');
  // TODO: Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð»Ð¾Ð³Ð¸ÐºÑƒ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ° Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²
});

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð´Ð»Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð³Ð¾ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° (callback_query Ñ regex)
bot.callbackQuery(/client_(.+)/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const clientId = ctx.match[1];
  const clients = loadClients();
  const client = clients.find(c => c.id === clientId);

  if (client) {
    let message = `*Ð˜Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¾ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ðµ ${client.firstName} ${client.lastName}*\n\n` +
                  `*ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ:* ${client.category === 'buyer' ? 'ÐŸÐ¾ÐºÑƒÐ¿Ð°Ñ‚ÐµÐ»ÑŒ' : 'ÐŸÑ€Ð¾Ð´Ð°Ð²ÐµÑ†'}\n` +
                  `*Ð¡Ñ‚Ð°Ñ‚ÑƒÑ:* ${client.status === 'active' ? 'ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹' : client.status === 'archived' ? 'ÐÑ€Ñ…Ð¸Ð²Ð½Ñ‹Ð¹' : 'Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½'}\n`;

    if (client.propertyInfo) {
      message += `\n*Ð˜Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¿Ð¾ Ð¾Ð±ÑŠÐµÐºÑ‚Ñƒ:*\n`;
      if (client.propertyInfo.type) message += `  Ð¢Ð¸Ð¿: ${client.propertyInfo.type}\n`;
      if (client.propertyInfo.requirements) message += `  Ð¢Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ: ${client.propertyInfo.requirements}\n`;
      if (client.propertyInfo.description) message += `  ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ: ${client.propertyInfo.description}\n`;
      if (client.propertyInfo.price) message += `  Ð¦ÐµÐ½Ð°: ${client.propertyInfo.price}\n`;
    }

    const keyboard = new InlineKeyboard();
    if (client.username) {
      keyboard.url(`ÐŸÐµÑ€ÐµÐ¹Ñ‚Ð¸ Ð² Ñ‡Ð°Ñ‚ Ñ ${client.firstName}`, `https://t.me/${client.username.startsWith('@') ? client.username.substring(1) : client.username}`);
    }

    if (keyboard.inline_keyboard.length > 0) {
      await ctx.reply(message, { parse_mode: 'Markdown', reply_markup: keyboard });
    } else {
      await ctx.reply(message, { parse_mode: 'Markdown' });
    }
  } else {
    await ctx.reply('ÐšÐ»Ð¸ÐµÐ½Ñ‚ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.');
  }
});

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ñ
const greetingRegex = /^(Ð¿Ñ€Ð¸Ð²ÐµÑ‚|Ð·Ð´Ñ€Ð°Ð²ÑÑ‚Ð²ÑƒÐ¹|Ð´Ð¾Ð±Ñ€Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ|Ð´Ð¾Ð±Ñ€Ð¾Ðµ ÑƒÑ‚Ñ€Ð¾|Ð´Ð¾Ð±Ñ€Ñ‹Ð¹ Ð²ÐµÑ‡ÐµÑ€|Ñ…ÐµÐ»Ð»Ð¾|Ñ…Ð°Ð¹|ÑÐ°Ð»ÑŽÑ‚)/i;
bot.hears(greetingRegex, async (ctx) => {
  console.log('Received event:', JSON.stringify(ctx));
  const businessConnectionId = ctx.businessConnectionId || ctx.message?.business_connection_id;
  if (businessConnectionId && ctx.chat.id === ctx.from?.id) {
    const now = new Date();
    const hour = now.getHours();
    let timeBasedGreeting = '';
    if (hour >= 5 && hour < 12) timeBasedGreeting = 'Ð”Ð¾Ð±Ñ€Ð¾Ðµ ÑƒÑ‚Ñ€Ð¾';
    else if (hour >= 12 && hour < 17) timeBasedGreeting = 'Ð”Ð¾Ð±Ñ€Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ';
    else if (hour >= 17 && hour < 22) timeBasedGreeting = 'Ð”Ð¾Ð±Ñ€Ñ‹Ð¹ Ð²ÐµÑ‡ÐµÑ€';
    else timeBasedGreeting = 'Ð”Ð¾Ð±Ñ€Ð¾Ð¹ Ð½Ð¾Ñ‡Ð¸';

    let userName = '';
    if (ctx.from?.first_name && /^[Ð°-ÑÐ-Ð¯Ñ‘Ð\s]+$/.test(ctx.from.first_name)) {
      userName = `, ${ctx.from.first_name}`;
    }

    const greetings = [
      `${timeBasedGreeting}${userName}`,
      `Ð—Ð´Ñ€Ð°Ð²ÑÑ‚Ð²ÑƒÐ¹${userName}`,
      `ÐŸÑ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽ${userName}`,
      `ÐŸÑ€Ð¸Ð²ÐµÑ‚${userName}`,
      `${timeBasedGreeting.toLowerCase()}${userName}`
    ];
    let finalGreeting = greetings[Math.floor(Math.random() * greetings.length)];
    if (Math.random() < 0.7) finalGreeting += '!';
    try {
      await ctx.reply(finalGreeting);
    } catch (error) {
      console.error('Error sending message via business connection:', error);
    }
  }
});

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Cloud Function
export async function handler(event: any, context?: any) {
  console.log('Received event:', JSON.stringify(event));
  try {
    if (!botInitialized) {
      await initializeBot();
    }

    if (!event.body) {
      console.error('Event body is missing');
      return { statusCode: 400, body: 'Event body is missing' };
    }
    let updateString = event.body;
    if (typeof event.body !== 'string') {
        updateString = JSON.stringify(event.body);
    }
    const update = JSON.parse(updateString);
    console.log('Parsed update:', JSON.stringify(update));

    // ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÐ¼ business_message Ð² ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Telegram
    if (update.business_message) {
      update.message = {
        ...update.business_message,
        business_connection_id: update.business_message.business_connection_id
      };
    }

    await bot.handleUpdate(update);
    return { statusCode: 200, body: 'OK' };

  } catch (err: any) {
    console.error('Error in handler:', err);
    const errorMessage = err.message || 'Unknown error';
    const errorStack = err.stack || 'No stack trace';
    console.error(`Error message: ${errorMessage}, Stack: ${errorStack}`);
    return { statusCode: 500, body: `Error processing update: ${errorMessage}` };
  }
}
